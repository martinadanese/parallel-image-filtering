#include <string.h>
#include <omp.h>
#include <stdlib.h>
#include <stdio.h> 
#include <math.h>
#include <time.h>
#define KSIDE 3 
#define NTHS  8
#define XWIDTH 256
#define YWIDTH 256
// 256*256 = 65,536
#define MAXVAL 65535

#define CPU_TIME (clock_gettime( CLOCK_PROCESS_CPUTIME_ID, &ts ), (double)ts.tv_sec + \
		  (double)ts.tv_nsec * 1e-9)

#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif


// ============================================================================================================================================================
// 1. utilities for managinf pgm files
//
//  * write_pgm_image
//  * read_pgm_image
//  * swap_image
//  
// 2. routine for bluring an image
//
//  * blur
//
// ============================================================================================================================================================
//  WRITE 

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  //

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# M. Danese \n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;

  /* ---------------------------------------------------------------

     TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
           ASCII  BINARY

     PBM   P1     P4       .pbm        [0-1]
     PGM   P2     P5       .pgm        [0-255]
     PPM   P3     P6       .ppm        [0-2^16[
  
  ------------------------------------------------------------------ */
}


// ============================================================================================================================================================


//                               READ PGM


void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;

    
  /* --------------------------------------------------------------- */


  // get the Magic Number - first element
  k = fscanf(image_file, "%2s%*c", MagicN );


    
  /* --------------------------------------------------------------- */


  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

    
  /* --------------------------------------------------------------- */


  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	if(fscanf(image_file, "%d%*c", maxval)!=1){
	  printf("no maxval was provided\n");
	  return;
	}
    }
  // in the case I am givning some bad input
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  

    
  /* --------------------------------------------------------------- */


  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}


// ============================================================================================================================================================


//                               SWAP PGM



void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i++ )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}



// ============================================================================================================================================================


//                               BLUR PGM


void * blur( void *image, int xsize, int ysize, int start_idx, int start_x, int start_y, int xxth, int yyth, int xpxl, int ypxl, int maxval, int ksize, float kernel[ksize][ksize], float knorm, int khalfsize)
/*
  This routine takes as input the image to blur, its x and y size, its maxval (as above), 
  the kernel size (ksize), the kernel matrix valuse and its normalisation  
 */
{
  short int *sImage;   
  void      *tempptr;
 
  start_y /= xsize; // instead of repeating this division at every loop

      sImage = (unsigned short int*)malloc( xpxl*ypxl*sizeof(short int) );
      unsigned short int _maxval = swap((unsigned short int)maxval);
      for ( int yy = 0; yy < ypxl; yy++ ){
        for( int xx = 0; xx < xpxl; xx++ ){
        int idx = start_idx + yy*xsize + xx; 
	  //to store partial results
	  double xxyy = 0;
	  //loop over the kernel
	  for (int yks=-khalfsize; yks<khalfsize+1; yks++){
	    for (int xks=-khalfsize; xks<khalfsize+1; xks++){
	      if (start_x + xx + xks < xsize && start_y + yy + yks < ysize  && start_x+xx+xks >= 0 && start_y+yy+yks >=0){
	        int sidx = idx + yks*xsize + xks; 
	        xxyy += kernel[khalfsize+yks][khalfsize+xks]*((unsigned short int*)image)[sidx];
	        }
              }
	    }
	    sImage[yy*xpxl+xx] = round(xxyy/knorm);
	    idx++;
          }
	}
      tempptr = (void*)sImage;	

  return tempptr;
}



// ============================================================================================================================================================


//                               MAIN


// ============================================================================================================================================================


int main( int argc, char **argv ) 
{ 
    int xsize      = XWIDTH;
    int ysize      = YWIDTH;
    int maxval     = MAXVAL;
    int ksize      = KSIDE;
    int ktype      = 0;
    float kfactor  = 0.2;
    struct timespec ts;
    char *input_image_name;
    char *output_image_name;
    double startt, stopt;
    int nths=NTHS, nthsx, nthsy;
  
    
    xsize  = 0;
    ysize  = 0;
    maxval = 0;
    ksize  = 25;
    void *ptr; 

    // read input parameters
    int arg_num=1;
    if( argc > arg_num){
     nths    = atoi ( argv[arg_num] );
     omp_set_num_threads(nths);
     arg_num++;
    if ( argc > arg_num ) {
     ktype   = atoi( argv[arg_num] );
     arg_num++;
     if (ktype>2 || ktype <0){
       printf("Invalid ktype\n");
       return 0;
       }
    if ( argc > arg_num ) {
     ksize   = atoi( argv[arg_num] );
     arg_num++;
    if (ktype==1) {if ( argc > arg_num) {
                     kfactor = atof( argv[arg_num]);
                     arg_num++;
                     if (kfactor>1 || kfactor<0){
                       printf("Invalid kfactor\n");
                       return 0;
                     }
                   }
    }
    if ( argc > arg_num ) {
     input_image_name  = malloc(strlen( argv[arg_num])+1);
     strcpy(input_image_name, argv[arg_num]);
     arg_num++;
    if ( argc > arg_num ) {
     output_image_name  = malloc(strlen( argv[arg_num])+1);
     strcpy(output_image_name, argv[arg_num]);
     arg_num++;
     } } } } }
    
    //if no output image name is provided
    if(arg_num<(6+ktype%2)) {
     output_image_name  = malloc(15);
     strcpy(output_image_name, "omp_output.pgm");
    }
    if(arg_num<(5+ktype%2)) {
     input_image_name   = malloc(16);
     strcpy(input_image_name, "../check_me.pgm");
    }



    startt = omp_get_wtime();
   /*  ------------------------------------------------------- 
  
           KERNEL SET UP   
  
       ------------------------------------------------------- */

    float kernel[ksize][ksize];
    float knorm = 0;
    int khalfsize   = (ksize-1)/2; // radius of the kernel
    int kfactor_int = round(100*kfactor);


    // ---------------------------------------------
    // average kernel
    if (ktype==0) {
      for (int i=0; i<ksize;i++){
        for (int j=0; j<ksize;j++){
          kernel[i][j]=1;
	  knorm += kernel[i][j];
        }
      }
    }
    else if (ktype==1) {
    // ---------------------------------------------
    // weight kernel
      for (int i=0; i<ksize;i++){
        for (int j=0; j<ksize;j++){
          kernel[i][j]=1-kfactor;
        }
      }
      knorm = (ksize*ksize-1);
      kernel[khalfsize][khalfsize]=kfactor*(ksize*ksize-1);
    }
    else if (ktype==2) {
    
    // ---------------------------------------------
    // gaussian kernel
      float kden  = 1./(2.*khalfsize*khalfsize);
      knorm = 0;
      for (int i=0; i<ksize;i++){
	float ky=i-khalfsize;
        for (int j=0; j<ksize;j++){
	  float kx=j-khalfsize;
          kernel[i][j]=expf( -((kx*kx)+(ky*ky))*kden );
	  knorm += kernel[i][j];
	}
      }
    }



   /*  ------------------------------------------------------- 
  
           THREADS SET UP     
  
       -------------------------------------------------------

       The original image is divided into a grid of subimages.

         * nths        - total number of threads = number of 
	                 subimages to be considered
	 * nthsx       - number of division along the x axis
	 * nthsy       - number of division along the y axis
	 * xpxl[nthsx] - number of pixel in the x axis that 
	                 each column of subimages should have
	 * ypxl[nthsy] - number of pixel in the y axis that 
	                 each row of subimages should have
         * thid        - number of the current thread
         * xxth        - x coordinate of the sub image (see below)
         * yyth        - y coordinate of the sub image (see below)


          illustration with 9 threads (nths=9):
          best division: 3x3 grid (i.e. nthsx=3 and nthsy=3)

	       _________________________          original image       
              |  (0,0) '  (0,1) '  (0,2) |        divided in 9 subimages          
              |      0 '      1 '      2 |        following a 3x3 grid
              |--------'--------'--------|       / 
              |  (1,0) '  (1,1) '  (1,2) |   <--ˊ
              |      3 '      4 '      5 |               subimage:
              |--------'--------'--------|            ---------------  ^
              |  (2,0) '  (2,1) '  (2,2) |           '  (yyth,xxth) '  |
	      | _____6_'______7_'______8_|           '         thid '  |  ypxl[yyth]
                                                     '--------------'  ˅

						        xpxl[xxth] 
						      <------------->
						        

       ------------------------------------------------------- */
  
    
    // ---------------------------------------------
    //split image in sub images: one for every thread

    // best division when nthsx and nthsx are as similar as possible
    if (nths !=1){
      int div = floor(nths/2);
      while (nths%div!=0) {
        div--;
        }
      nthsy = nths/div;
      nthsx = div;
    
      while(nthsx%nthsy==0 && nthsx!=nthsy && nthsx>1){
        nthsx /= 2;
        nthsy *= 2;
        }
    }
    else{ //if just one thread is present, there should be no division
      nthsx = 1;
      nthsy = 1;
    }
  
  

    // ---------------------------------------------
    // read image
    read_pgm_image( &ptr, &maxval, &xsize, &ysize, input_image_name);

    // ---------------------------------------------
    // find best number of pixels for the subimages

    int xpxl[nthsx];
    int ypxl[nthsy];
    // x axis
    for (int i=0; i<nthsx; i++){
      xpxl[i] = floor(xsize/nthsx); //even division of pixels
      if (i<xsize%nthsx) xpxl[i]++;  // homogeneous addition of extra pixels
    }
    // y axis is analogous
    for (int i=0; i<nthsy; i++){
      ypxl[i] = floor(ysize/nthsy);
      if (i<ysize%nthsy) ypxl[i]++;
    }
    
   
   /*  ------------------------------------------------------- 
  
           BLURRING  
  
       ------------------------------------------------------- */
    
    // ---------------------------------------------
    // swap the endianism if necessary
    if ( I_M_LITTLE_ENDIAN )
      swap_image( ptr, xsize, ysize, maxval);
    //array of pointers where partial results will be stored
    void *rptr[nths];


    // things that should be done in the parallel region but are actually done outside bc of last part
    int xxth[nths], yyth[nths];
    for (int thid=0; thid<nths; thid++){
      yyth[thid] = floor(thid/nthsx);
      xxth[thid] = thid%nthsx;
    }

    int thid = omp_get_thread_num();
    int start_idx[nths], start_x[nths], start_y[nths];
    
    // ---------------------------------------------
    // identify starting index for subimages
    for (int thid=0; thid<nths;thid++){
      start_idx[thid] = 0;
      start_x[thid]   = 0;
      start_y[thid]   = 0;
      for (int i=0; i<xxth[thid]; i++){
        start_x[thid] += xpxl[i];
      }
      for (int i=0; i<yyth[thid]; i++){
        start_y[thid] += ypxl[i];
      }
      start_y[thid] *= xsize;
      start_idx[thid] = start_x[thid] + start_y[thid];
    }

  #pragma omp parallel proc_bind(close)
  {
    int thid = omp_get_thread_num();
    // ---------------------------------------------
    // blur sub image
    rptr[thid] = blur( ptr, xsize, ysize, start_idx[thid], start_x[thid], start_y[thid], xxth[thid], yyth[thid], xpxl[xxth[thid]], ypxl[yyth[thid]], maxval, ksize, kernel, knorm, khalfsize);
  }

    // write the image
    short int *final_image;  
    final_image = (unsigned short int*)malloc( xsize*ysize* sizeof(short int) );
    for ( int thid = 0; thid < nths; thid++ ){
      for ( int yy = 0; yy < ypxl[yyth[thid]]; yy++ ){
        for ( int xx = 0; xx < xpxl[xxth[thid]]; xx++ ){
          int idx = start_idx[thid] + yy*xsize + xx; //every row we complete we add it in the index count
          final_image[idx]=((unsigned short int*)rptr[thid])[yy*xpxl[xxth[thid]]+xx];
        }
      }
    }


    // ---------------------------------------------
    // swap the endianism back
    if ( I_M_LITTLE_ENDIAN )
      swap_image( final_image, xsize, ysize, maxval);



   /*  ------------------------------------------------------- 
  
           SAVE AND FINISH
  
       ------------------------------------------------------- */
    write_pgm_image( final_image, maxval, xsize, ysize, output_image_name);

    stopt = omp_get_wtime();
    printf("Elapsed time  (opm): %f\n", stopt-startt);
    free(ptr);
    free(final_image);
    free(input_image_name);
    for (int i=0; i<nths; i++)
      free(rptr[i]);
    return 0;
} 



